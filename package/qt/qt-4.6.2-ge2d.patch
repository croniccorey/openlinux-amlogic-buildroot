diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibplugin.cpp qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibplugin.cpp
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibplugin.cpp	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibplugin.cpp	2010-08-03 18:56:45.686149000 +0800
@@ -0,0 +1,40 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#include "ge2dlibscreen.h"
+
+#include <QScreenDriverPlugin>
+#include <QStringList>
+
+class Ge2dlibPlugin : public QScreenDriverPlugin
+{
+public:
+    Ge2dlibPlugin();
+
+    QStringList keys() const;
+    QScreen *create(const QString&, int displayId);
+};
+
+Ge2dlibPlugin::Ge2dlibPlugin()
+    : QScreenDriverPlugin()
+{
+}
+
+QStringList Ge2dlibPlugin::keys() const
+{
+    return (QStringList() << "ge2dlib");
+}
+
+QScreen* Ge2dlibPlugin::create(const QString& driver, int displayId)
+{
+    if (driver.toLower() != "ge2dlib")
+        return 0;
+
+    return new Ge2dlibScreen(displayId);
+}
+
+Q_EXPORT_STATIC_PLUGIN(ge2dlib)
+Q_EXPORT_PLUGIN2(ge2dlibscreendriver, Ge2dlibPlugin)
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.cpp qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.cpp
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.cpp	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.cpp	2010-08-03 18:56:45.688893000 +0800
@@ -0,0 +1,220 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#include <stdio.h>
+
+#include "qwsdisplay_qws.h"
+#include "ge2dlibscreen.h"
+#include "ge2dlibsurface.h"
+#include "ge2dlibsharedsurface.h"
+
+
+#include <QColor>
+#include <QWidget>
+#include <QApplication>
+#include <qdebug.h>
+
+
+QT_BEGIN_NAMESPACE
+
+
+CMEM_AllocParams Ge2dlibScreen::cmemParams = {CMEM_HEAP, CMEM_NONCACHED, 8};
+bool Ge2dlibScreen::connect(const QString &displaySpec)
+{
+    // Check for explicitly specified device
+    QString  dev;
+     dev = QLatin1String("/dev/ge2d");
+
+    if (access(dev.toLatin1().constData(), R_OK|W_OK) == 0)
+        devfd = open(dev.toLatin1().constData(), O_RDWR);
+    if (devfd == -1) {
+        if (QApplication::type() == QApplication::GuiServer) {
+            perror("QScreenLinuxFb::connect");
+            qCritical("Error opening framebuffer device %s", qPrintable(dev));
+            return false;
+        }
+        if (access(dev.toLatin1().constData(), R_OK) == 0)
+            devfd = open(dev.toLatin1().constData(), O_RDONLY);
+    }
+     
+    if (CMEM_init() < 0) {
+		close(devfd);
+        return false;
+    }
+
+    return QLinuxFbScreen::connect(displaySpec);
+}
+
+void Ge2dlibScreen::disconnect()
+{
+	close(devfd);
+	
+	CMEM_exit();
+
+    QLinuxFbScreen::disconnect();
+}
+static  inline   int  AddrInRegion(unsigned long addr, unsigned long start, unsigned long end)
+{
+	return  (addr >= start)&&(addr<end);
+}
+void Ge2dlibScreen::blit(const QImage &img, const QPoint &topLeft, const QRegion &region)
+{
+    const QRect bound = (QScreen::region() & QRect(topLeft, img.size())).boundingRect();
+		const QRegion reg = (region & bound).translated(-topLeft);
+
+    const QVector<QRect> rects = reg.rects();
+    config_para_t ge2d_config;
+    ge2d_op_para_t op_para;
+    CMEM_BlockAttrs pattrs ;
+	int CMEM_getBlockAttrs(int blockid, CMEM_BlockAttrs *pattrs);
+
+	if (img.depth() < 16) {
+		QScreen::blit(img, topLeft, region);
+		return;
+	}
+	
+	ge2d_config.src_planes[0].addr= CMEM_getPhys((uchar *)img.scanLine(0));
+	if(0>CMEM_getBlockAttrs(0,&pattrs))
+	{	
+		QScreen::blit(img, topLeft, region);
+		return;
+	}
+	if (!ge2d_config.src_planes[0].addr || !AddrInRegion(ge2d_config.src_planes[0].addr , pattrs.phys_base,pattrs.phys_base+pattrs.size)) {
+		printf("--------------------cmem address:0x%x,size:(%d:%d),back\n",ge2d_config.src_planes[0].addr,img.size().width(),img.size().height());	
+		QScreen::blit(img, topLeft, region);
+		return;
+	}
+	printf("--------------------cmem address:0x%x,size:(%d:%d)accel\n",ge2d_config.src_planes[0].addr,img.size().width(),img.size().height());
+	ge2d_config.src_dst_type = ALLOC_OSD0;
+	ge2d_config.alu_const_color=0xff0000ff;
+	ge2d_config.src_planes[0].w= img.width();
+	ge2d_config.src_planes[0].h= img.height();
+
+
+    switch (img.format()) {
+	/* 32 bpp */
+    case QImage::Format_RGB32:
+    case QImage::Format_ARGB32:
+    case QImage::Format_ARGB32_Premultiplied:
+		ge2d_config.src_format = GE2D_FORMAT_S32_ARGB;
+		break;
+	/* 24 bpp */
+	case QImage::Format_RGB888:
+	case QImage::Format_RGB666:
+		ge2d_config.src_format = GE2D_FORMAT_S24_RGB;
+		break;
+	case QImage::Format_ARGB6666_Premultiplied:
+	case QImage::Format_ARGB8555_Premultiplied:
+		ge2d_config.src_format = GE2D_FORMAT_S24_ARGB_6666;
+		break;
+	case QImage::Format_ARGB8565_Premultiplied:
+		ge2d_config.src_format = GE2D_FORMAT_S24_ARGB_8565;
+		break;
+	/* 16 bpp */
+    case QImage::Format_RGB16:
+		ge2d_config.src_format = GE2D_FORMAT_S16_RGB_565;
+	    break;
+    case QImage::Format_RGB555:
+		ge2d_config.src_format = GE2D_FORMAT_S16_ARGB_1555;
+		break;
+	case QImage::Format_ARGB4444_Premultiplied:
+    case QImage::Format_RGB444:
+		ge2d_config.src_format = GE2D_FORMAT_S16_ARGB_4444;
+		break;
+	default:
+    	qCritical("blit_32(): Image format %d not supported!", img.format());
+    }
+
+    QWSDisplay::grab();
+
+    ioctl(devfd, FBIOPUT_GE2D_CONFIG, &ge2d_config);
+   // printf("stretch blit no alpha\r\n"); 
+    for (int i = 0; i < rects.size(); ++i) {
+        const QRect r = rects.at(i);
+
+        op_para.src1_rect.x = r.x();
+        op_para.src1_rect.y = r.y();
+        op_para.src1_rect.w = r.width();
+        op_para.src1_rect.h = r.height();
+
+#ifdef GE2DSCRREN_DEBUG
+		qDebug("Src: (0x%x->0x%x, %d, %d, %d, %d), imageStride = %d \n",
+			(unsigned)img.scanLine(0), (unsigned)ge2d_config.src_addr,
+			r.x(), r.y(), r.width(), r.height(),
+			img.bytesPerLine());
+#endif
+		op_para.dst_rect.x = topLeft.x() + r.x();
+		op_para.dst_rect.y = topLeft.y() + r.y();
+		op_para.dst_rect.w = r.width();
+		op_para.dst_rect.h = r.height();
+
+#ifdef GE2DSCRREN_DEBUG
+		qDebug("Dst: (0x%x, %d, %d), screenStride = %d\n",
+				(unsigned)base(),
+				(topLeft - offset()).x(), (topLeft - offset()).y(), linestep());
+#endif
+	 printf("stretch blit no alpha:%d-%d-%d-%d\r\n",op_para.dst_rect.x,op_para.dst_rect.y,op_para.dst_rect.w,op_para.dst_rect.h);
+        ioctl(devfd, FBIOPUT_GE2D_BLIT_NOALPHA, &op_para);
+    }
+
+    QWSDisplay::ungrab();
+}
+
+void Ge2dlibScreen::solidFill(const QColor &color, const QRegion &region)
+{
+    ge2d_op_para_t op_para;
+    QRect bound(0, 0, dw, dh);
+    
+	op_para.color = (color.blue()<<24)|(color.green()<<16)|(color.red()<<8)|color.alpha();
+
+    QWSDisplay::grab();
+
+    const QVector<QRect> rects = region.rects();
+    for (int i = 0; i < rects.size(); ++i) {
+        const QRect r = rects.at(i) & bound;
+        
+        op_para.src1_rect.x = r.x();
+        op_para.src1_rect.y = r.y();
+        op_para.src1_rect.w = r.width();
+        op_para.src1_rect.h = r.height();
+        if(r.width() <= 0 || r.height() <= 0)
+            continue;
+         
+        ioctl(devfd, FBIOPUT_GE2D_FILLRECTANGLE, &op_para);
+    }
+
+    QWSDisplay::ungrab();
+}
+
+QWSWindowSurface* Ge2dlibScreen::createSurface(QWidget *widget) const
+{
+    if (QApplication::type() == QApplication::GuiServer)
+    {
+    	 qCritical("++++++++widget surface********************");
+        return new Ge2dlibSurface(widget);
+    }		
+#ifndef QT_NO_QWS_MULTIPROCESS
+    else
+        return new Ge2dlibSharedSurface(widget);
+#endif
+
+    return 0;
+}
+
+QWSWindowSurface* Ge2dlibScreen::createSurface(const QString &key) const
+{
+    if (key == QLatin1String("ge2dlib")) {
+	   qCritical("++++++++key surface********************");	
+        return new Ge2dlibSurface;
+    }
+#ifndef QT_NO_QWS_MULTIPROCESS
+    else if (key == QLatin1String("ge2dlibshm"))
+        return new Ge2dlibSharedSurface;
+#endif
+    return 0;
+}
+
+QT_END_NAMESPACE
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.h qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.h
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.h	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibscreen.h	2010-08-04 10:12:42.028644000 +0800
@@ -0,0 +1,38 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#ifndef GE2DLIBSCREEN_H
+#define GE2DLIBSCREEN_H
+
+#include <QLinuxFbScreen>
+#include <ge2d.h>
+#include "cmem.h"
+
+QT_BEGIN_NAMESPACE
+
+class Q_GUI_EXPORT Ge2dlibScreen : public QLinuxFbScreen
+{
+public:
+    Ge2dlibScreen(int displayId) : QLinuxFbScreen(displayId) {}
+    ~Ge2dlibScreen() {}
+
+    bool connect(const QString &displaySpec);
+    void disconnect();
+
+    void blit(const QImage &img, const QPoint &topLeft, const QRegion &region);
+    void solidFill(const QColor &color, const QRegion &region);
+
+    QWSWindowSurface* createSurface(QWidget *widget) const;
+    QWSWindowSurface* createSurface(const QString &key) const;
+
+private:
+	int devfd;
+	static CMEM_AllocParams cmemParams;
+};
+
+QT_END_NAMESPACE
+
+#endif // GE2DLIBSCREEN_H
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.cpp qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.cpp
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.cpp	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.cpp	2010-08-04 10:12:50.428644000 +0800
@@ -0,0 +1,226 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#include <stdio.h>
+#include "ge2dlibsharedsurface.h"
+#include "cmem.h"
+
+#include <qwidget.h>
+#include <qscreen_qws.h>
+#include <qapplication.h>
+#include <qwsdisplay_qws.h>
+#include <qrgb.h>
+#include <qpaintengine.h>
+#include <qdesktopwidget.h>
+#include <private/qwsdisplay_qws_p.h>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_QWS_MULTIPROCESS
+
+static inline QScreen *getScreen(const QWidget *w)
+{
+    const QList<QScreen*> subScreens = qt_screen->subScreens();
+    if (subScreens.isEmpty())
+        return qt_screen;
+
+    const int screen = QApplication::desktop()->screenNumber(w);
+
+    return qt_screen->subScreens().at(screen < 0 ? 0 : screen);
+}
+
+static int bytesPerPixel(QImage::Format format)
+{
+    switch (format) {
+    case QImage::Format_Invalid:
+        return 0;
+#ifndef QT_NO_DEBUG
+    case QImage::Format_Mono:
+    case QImage::Format_MonoLSB:
+        qFatal("QWSWindowSurface: Invalid backingstore format: %i",
+               int(format));
+#endif
+    case QImage::Format_Indexed8:
+        return 1;
+    case QImage::Format_RGB32:
+    case QImage::Format_ARGB32:
+    case QImage::Format_ARGB32_Premultiplied:
+        return 4;
+    case QImage::Format_RGB16:
+    case QImage::Format_RGB555:
+    case QImage::Format_RGB444:
+    case QImage::Format_ARGB4444_Premultiplied:
+        return 2;
+    case QImage::Format_ARGB8565_Premultiplied:
+    case QImage::Format_ARGB8555_Premultiplied:
+    case QImage::Format_ARGB6666_Premultiplied:
+    case QImage::Format_RGB666:
+    case QImage::Format_RGB888:
+        return 3;
+    default:
+#ifndef QT_NO_DEBUG
+        qFatal("QWSWindowSurface: Invalid backingstore format: %i",
+               int(format));
+#endif
+        return 0;
+    }
+}
+
+static inline int nextMulOf8(int n)
+{
+    return ((n + 7) & 0xfffffff8);
+}
+
+static inline void setImageMetrics(QImage &img, QWidget *window) {
+    QScreen *myScreen = getScreen(window);
+    if (myScreen) {
+        int dpmx = myScreen->width()*1000 / myScreen->physicalWidth();
+        int dpmy = myScreen->height()*1000 / myScreen->physicalHeight();
+        img.setDotsPerMeterX(dpmx);
+        img.setDotsPerMeterY(dpmy);
+    }
+}
+
+CMEM_AllocParams Ge2dlibSharedSurface::cmemParams = {CMEM_HEAP, CMEM_NONCACHED, 8};
+ 
+Ge2dlibSharedSurface::Ge2dlibSharedSurface()
+    : QWSMemorySurface(), mem(0), memId(0)
+{
+}
+
+Ge2dlibSharedSurface::Ge2dlibSharedSurface(QWidget *w)
+    : QWSMemorySurface(w), mem(0), memId(0)
+{
+}
+
+Ge2dlibSharedSurface::~Ge2dlibSharedSurface()
+{
+    if (mem)
+        CMEM_free(mem, &cmemParams);
+}
+
+void Ge2dlibSharedSurface::setGeometry(const QRect &rect)
+{
+    const QSize size = rect.size();
+
+    if (img.size() != size) {
+        if (size.isEmpty()) {
+			if (mem) {
+		        CMEM_free(mem, &cmemParams);
+            	mem = 0;
+            	memId = 0;
+           	}
+            img = QImage();
+        } else {
+			if (mem) {
+		        CMEM_free(mem, &cmemParams);
+            	mem = 0;
+            	memId = 0;
+           	}
+
+            QWidget *win = window();
+            const QImage::Format format = preferredImageFormat(win);
+            const int bpl = nextMulOf8(bytesPerPixel(format) * size.width());
+#ifdef QT_QWS_CLIENTBLIT
+            const int imagesize = bpl * size.height() + sizeof(uint);
+#else
+            const int imagesize = bpl * size.height();
+#endif
+
+#ifdef QT_QWS_CLIENTBLIT
+			mem = (uchar *)CMEM_alloc(0, imagesize + sizeof(uint), &cmemParams);
+#else
+			mem = (uchar *)CMEM_alloc(0, imagesize, &cmemParams);
+#endif
+			memId = CMEM_getPhys(mem);
+
+            if (!mem) {
+                perror("QWSSharedMemSurface::setGeometry allocating shared memory");
+                qFatal("Error creating shared memory of size %d", imagesize);
+            }
+            img = QImage(mem, size.width(), size.height(), bpl, format);
+            setImageMetrics(img, win);
+        }
+    }
+
+    QWSWindowSurface::setGeometry(rect);
+}
+
+QByteArray Ge2dlibSharedSurface::permanentState() const
+{
+    QByteArray array;
+    array.resize(6 * sizeof(int));
+
+    int *ptr = reinterpret_cast<int*>(array.data());
+
+	if (mem)
+    	ptr[0] = CMEM_getPhys(mem);
+   	else
+    	ptr[0] = 0;
+    ptr[1] = img.width();
+    ptr[2] = img.height();
+    ptr[3] = (memlock ? memlock->id() : -1);
+    ptr[4] = int(img.format());
+    ptr[5] = int(surfaceFlags());
+
+    return array;
+}
+
+void Ge2dlibSharedSurface::setPermanentState(const QByteArray &data)
+{
+    int width;
+    int height;
+    int lockId;
+    QImage::Format format;
+    SurfaceFlags flags;
+
+    const int *ptr = reinterpret_cast<const int*>(data.constData());
+
+    width = ptr[1];
+    height = ptr[2];
+    lockId = ptr[3];
+    format = QImage::Format(ptr[4]);
+    flags = SurfaceFlags(ptr[5]);
+
+    setSurfaceFlags(flags);
+
+	if (ptr[0] != memId) {
+		if (mem)
+			CMEM_free(mem, &cmemParams);
+	}
+	memId = ptr[0];
+	if (memId) {
+    	mem = (uchar *)CMEM_registerAlloc(memId);
+
+		if (!mem) {
+        	perror("QWSSharedMemSurface: attaching to shared memory");
+        	qCritical("QWSSharedMemSurface: Error attaching to"
+            	      " shared memory 0x%x", memId);
+        }
+   	} else
+   		mem = 0;
+
+#ifdef GE2DSCRREN_DEBUG
+	qDebug("Ge2dlibSharedSurface::setPermanentState, 0x%x->0x%x\n",
+			memId, (unsigned)mem);
+#endif
+
+    setLock(lockId);
+
+    const int bpl = nextMulOf8(bytesPerPixel(format) * width);
+    QWSMemorySurface::img = QImage(mem, width, height, bpl, format);
+}
+
+void Ge2dlibSharedSurface::releaseSurface()
+{
+    mem = 0;
+    memId = 0;
+    img = QImage();
+}
+
+#endif
+
+QT_END_NAMESPACE
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.h qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.h
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.h	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsharedsurface.h	2010-08-04 10:12:33.116644000 +0800
@@ -0,0 +1,42 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#ifndef GE2DLIBSHAREDSURFACE_H
+#define GE2DLIBSHAREDSURFACE_H
+
+#include <private/qwindowsurface_qws_p.h>
+#include "cmem.h"
+
+QT_BEGIN_NAMESPACE
+
+class Q_GUI_EXPORT Ge2dlibSharedSurface : public QWSMemorySurface
+{
+public:
+    Ge2dlibSharedSurface();
+    Ge2dlibSharedSurface(QWidget *widget);
+    ~Ge2dlibSharedSurface();
+
+    void setGeometry(const QRect &rect);
+
+    QString key() const { return QLatin1String("ge2dlibshm"); }
+    QByteArray permanentState() const;
+
+    void setPermanentState(const QByteArray &data);
+    virtual void releaseSurface();
+
+    int id() const { return memId; }
+
+protected:
+    uchar *mem;
+    int memId;
+    
+private:
+    static CMEM_AllocParams cmemParams;
+};
+
+QT_END_NAMESPACE
+
+#endif // GE2DLIBSHAREDSURFACE_H
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.cpp qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.cpp
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.cpp	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.cpp	2010-08-03 18:56:45.688893000 +0800
@@ -0,0 +1,236 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#include <stdio.h>
+
+#include "ge2dlibsurface.h"
+#include <qwidget.h>
+#include <qscreen_qws.h>
+#include <qapplication.h>
+#include <qwsdisplay_qws.h>
+#include <qrgb.h>
+#include <qpaintengine.h>
+#include <qdesktopwidget.h>
+#include <private/qwsdisplay_qws_p.h>
+
+QT_BEGIN_NAMESPACE
+
+static inline QScreen *getScreen(const QWidget *w)
+{
+    const QList<QScreen*> subScreens = qt_screen->subScreens();
+    if (subScreens.isEmpty())
+        return qt_screen;
+
+    const int screen = QApplication::desktop()->screenNumber(w);
+
+    return qt_screen->subScreens().at(screen < 0 ? 0 : screen);
+}
+
+static int bytesPerPixel(QImage::Format format)
+{
+    switch (format) {
+    case QImage::Format_Invalid:
+        return 0;
+#ifndef QT_NO_DEBUG
+    case QImage::Format_Mono:
+    case QImage::Format_MonoLSB:
+        qFatal("QWSWindowSurface: Invalid backingstore format: %i",
+               int(format));
+#endif
+    case QImage::Format_Indexed8:
+        return 1;
+    case QImage::Format_RGB32:
+    case QImage::Format_ARGB32:
+    case QImage::Format_ARGB32_Premultiplied:
+        return 4;
+    case QImage::Format_RGB16:
+    case QImage::Format_RGB555:
+    case QImage::Format_RGB444:
+    case QImage::Format_ARGB4444_Premultiplied:
+        return 2;
+    case QImage::Format_ARGB8565_Premultiplied:
+    case QImage::Format_ARGB8555_Premultiplied:
+    case QImage::Format_ARGB6666_Premultiplied:
+    case QImage::Format_RGB666:
+    case QImage::Format_RGB888:
+        return 3;
+    default:
+#ifndef QT_NO_DEBUG
+        qFatal("QWSWindowSurface: Invalid backingstore format: %i",
+               int(format));
+#endif
+        return 0;
+    }
+}
+
+static inline int nextMulOf8(int n)
+{
+    return ((n + 7) & 0xfffffff8);
+}
+
+static inline void setImageMetrics(QImage &img, QWidget *window) {
+    QScreen *myScreen = getScreen(window);
+    if (myScreen) {
+        int dpmx = myScreen->width()*1000 / myScreen->physicalWidth();
+        int dpmy = myScreen->height()*1000 / myScreen->physicalHeight();
+        img.setDotsPerMeterX(dpmx);
+        img.setDotsPerMeterY(dpmy);
+    }
+}
+
+CMEM_AllocParams Ge2dlibSurface::cmemParams = {CMEM_HEAP, CMEM_NONCACHED, 8};
+ 
+Ge2dlibSurface::Ge2dlibSurface()
+    : QWSMemorySurface(), 
+ 	mem(0)
+{
+	
+}
+
+Ge2dlibSurface::Ge2dlibSurface(QWidget *w)
+    : QWSMemorySurface(w), 
+      mem(0)
+{
+}
+
+Ge2dlibSurface::~Ge2dlibSurface()
+{
+	
+}
+/*
+QPaintDevice * Ge2dlibSurface::paintDevice()
+{
+	return new QGE2DBPaintDevice(&img) ;
+}*/
+
+void Ge2dlibSurface::setGeometry(const QRect &rect)
+{
+    QSize size = rect.size();
+
+    QWidget *win = window();
+    if (win && !win->mask().isEmpty()) {
+        const QRegion region = win->mask()
+                               & rect.translated(-win->geometry().topLeft());
+        size = region.boundingRect().size();
+    }
+    qCritical("new enter setGeometry, ");
+		
+    uchar *deleteLater = 0;
+    // In case of a Hide event we need to delete the memory after sending the
+    // event to the server in order to let the server animate the event.
+    if (size.isEmpty()) {
+        deleteLater = mem;
+        mem = 0;
+    }
+     qCritical("enter setGeometry,size(%d,%d),image(%d,%d)",size.width(),size.height(),
+	 			img.size().width(),img.size().height());	
+    if (img.size() != size) {
+		if (mem) {
+			 qCritical("CMEM release memory ++ 0x%08x\n",mem);
+   			CMEM_free(mem, &cmemParams);
+   		}
+
+        if (size.isEmpty()) {
+            mem = 0;
+            img = QImage();
+        } else {
+            const QImage::Format format = preferredImageFormat(win);
+            const int bpl = nextMulOf8(bytesPerPixel(format) * size.width());
+            const int memsize = bpl * size.height();
+            mem = (uchar *)CMEM_alloc(0, memsize, &cmemParams);
+	     qCritical("mem:0x%x,format:%d,bpl:%d,memsize:%d",mem,format,bpl,memsize);
+            if (!mem) {
+#ifndef QT_NO_DEBUG
+                qFatal("CMEM allocation failure, size 0x%x\n",
+                	memsize);
+#endif
+            }
+            else {            
+                img = QImage(mem, size.width(), size.height(), bpl, format);
+		   printf("+++++++++++++++++++++++++mem alloc at:0x%x\n",CMEM_getPhys((uchar *)img.scanLine(0)))	;	
+                setImageMetrics(img, win);
+            }
+        }
+    }
+
+    QWSWindowSurface::setGeometry(rect);
+  	if (deleteLater) {
+	 qCritical("CMEM release memory -- 0x%08x\n",deleteLater);	
+    	CMEM_free(deleteLater, &cmemParams);
+	}
+}
+
+QByteArray Ge2dlibSurface::permanentState() const
+{
+    QByteArray array;
+    array.resize(sizeof(uchar*) + 3 * sizeof(int) +
+                 sizeof(SurfaceFlags));
+
+    char *ptr = array.data();
+
+    *reinterpret_cast<uchar**>(ptr) = mem;
+    ptr += sizeof(uchar*);
+
+    reinterpret_cast<int*>(ptr)[0] = img.width();
+    reinterpret_cast<int*>(ptr)[1] = img.height();
+    ptr += 2 * sizeof(int);
+
+    *reinterpret_cast<int *>(ptr) = img.format();
+    ptr += sizeof(int);
+
+    *reinterpret_cast<SurfaceFlags*>(ptr) = surfaceFlags();
+
+    return array;
+}
+
+void Ge2dlibSurface::setPermanentState(const QByteArray &data)
+{
+    int width;
+    int height;
+    QImage::Format format;
+    SurfaceFlags flags;
+
+    const char *ptr = data.constData();
+
+    mem = *reinterpret_cast<uchar* const*>(ptr);
+    ptr += sizeof(uchar*);
+
+    width = reinterpret_cast<const int*>(ptr)[0];
+    height = reinterpret_cast<const int*>(ptr)[1];
+    ptr += 2 * sizeof(int);
+
+    format = QImage::Format(*reinterpret_cast<const int*>(ptr));
+    ptr += sizeof(int);
+
+    flags = *reinterpret_cast<const SurfaceFlags*>(ptr);
+
+    const int bpl = nextMulOf8(bytesPerPixel(format) * width);
+    QWSMemorySurface::img = QImage(mem, width, height, bpl, format);
+    setSurfaceFlags(flags);
+}
+static  inline   int  AddrInRegion(unsigned long addr, unsigned long start, unsigned long end)
+{
+	return  (addr >= start)&&(addr<end);
+}
+void Ge2dlibSurface::releaseSurface()
+{
+   if (mem) {
+   	unsigned int phy_addr;
+	CMEM_BlockAttrs pattrs ;
+	
+  	 phy_addr= CMEM_getPhys(mem);
+   	if(0>CMEM_getBlockAttrs(0,&pattrs))
+  	{	
+		return ;
+	}
+	if(AddrInRegion(phy_addr, pattrs.phys_base,pattrs.phys_base+pattrs.size))
+   	CMEM_free(mem, &cmemParams);
+   }
+
+    mem = 0;
+    img = QImage();
+}
+QT_END_NAMESPACE
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.h qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.h
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.h	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dlibsurface.h	2010-08-04 10:12:37.584762000 +0800
@@ -0,0 +1,44 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#ifndef GE2DLIBSURFACE_H
+#define GE2DLIBSURFACE_H
+
+#include <private/qpaintengine_raster_p.h>
+#include <private/qwindowsurface_qws_p.h>
+#include "ge2dlibscreen.h"
+#include "ge2dpaintdevice.h"
+#include "cmem.h"
+
+QT_BEGIN_NAMESPACE
+
+class Q_GUI_EXPORT Ge2dlibSurface : public QWSMemorySurface// ,public QGE2DBPaintDevice
+{
+public:
+    Ge2dlibSurface();
+    Ge2dlibSurface(QWidget *widget);
+    ~Ge2dlibSurface();
+
+    void setGeometry(const QRect &rect);
+    //QPaintDevice *paintDevice() ;
+    QString key() const { return QLatin1String("ge2dlib"); }
+    QByteArray permanentState() const;
+    void setPermanentState(const QByteArray &data);
+    virtual void releaseSurface();
+    	
+protected:
+    uchar *mem;
+ 
+    
+private:
+    static CMEM_AllocParams cmemParams;
+    	
+};
+
+QT_END_NAMESPACE
+
+#endif // GE2DLIBSURFACE_H
+
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.cpp qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.cpp
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.cpp	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.cpp	2010-08-03 18:56:45.688893000 +0800
@@ -0,0 +1,133 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at http://www.qtsoftware.com/contact.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include "ge2dpaintengine.h"
+#include "ge2dpaintdevice.h"
+
+QGE2DBPaintDevice::QGE2DBPaintDevice(QImage *img)
+:QCustomRasterPaintDevice(0),engine(0)
+ 
+{
+    image=img;
+}
+
+QGE2DBPaintDevice::~QGE2DBPaintDevice()
+{
+    
+}
+QPoint  QGE2DBPaintDevice::GetOffset() const
+{
+	return QPoint(image->offset());
+}
+
+void *QGE2DBPaintDevice::memory() const
+{
+    
+    return image->scanLine(0);
+   
+}
+
+//****************************************************
+//functions decend from paint device .
+//****************************************************
+
+
+QPaintEngine* QGE2DBPaintDevice::paintEngine() const
+{
+    if (!engine) {
+        QGE2DBPaintDevice *that = const_cast<QGE2DBPaintDevice*>(this);
+        that->engine = new QGE2DPaintEngine(that);
+        return that->engine;
+    }
+    return engine;
+}
+
+
+
+QImage::Format QGE2DBPaintDevice::format() const
+{
+    //qCritical("call format");
+    return image->format();
+}
+
+
+int QGE2DBPaintDevice::bytesPerLine() const
+{
+	//qCritical("call bytesPerLine");
+    return image->bytesPerLine();
+}
+
+
+QSize QGE2DBPaintDevice::size() const
+{
+	//qCritical("call size");
+    	return image->size();
+}
+
+int QGE2DBPaintDevice::metric(QPaintDevice::PaintDeviceMetric metric) const
+{
+	//qCritical("call metric");
+	int w,h;
+	w=image->width();
+	h=image->height();
+	 switch (metric) {
+    		case QPaintDevice::PdmWidth:
+        	return w;
+		break;	
+      		case QPaintDevice::PdmHeight:
+        	return h;
+        	break;
+    		case QPaintDevice::PdmNumColors:
+        	return image->numColors();
+		break;
+             case QPaintDevice::PdmDepth:
+             return image->depth();
+        	break;
+		break;
+   		default:
+        	qWarning("QImage::metric(): Unhandled metric type %d", metric);
+        	break;
+    	}
+    	return 0;
+}
+
+
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.h qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.h
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.h	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintdevice.h	2010-08-03 18:56:45.688893000 +0800
@@ -0,0 +1,77 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at http://www.qtsoftware.com/contact.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef GE2DPAINTDEVICE_H
+#define GE2DPAINTDEVICE_H
+
+#include <private/qpaintengine_raster_p.h>
+#include "ge2dlibscreen.h"
+//#include "ge2dpaintengine.h"
+
+QT_BEGIN_HEADER
+
+QT_MODULE(Gui)
+
+
+class QGE2DBPaintDevice : public QCustomRasterPaintDevice
+{
+public:
+	QGE2DBPaintDevice(QImage *img);
+    ~QGE2DBPaintDevice();
+    // Reimplemented from QCustomRasterPaintDevice:
+ 	QPaintEngine *paintEngine() const;
+	void *memory() const;
+	QPoint  GetOffset() const;
+	 	QImage::Format format() const;    
+		int bytesPerLine() const;  
+		QSize size() const; 
+		int metric(QPaintDevice::PaintDeviceMetric metric) const;
+ protected:
+ 	
+	
+	QImage  *image;
+	QRasterPaintEngine *engine;
+	
+};
+
+QT_END_HEADER
+
+#endif //GE2DPAINTDEVICE_H
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.cpp qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.cpp
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.cpp	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.cpp	2010-08-04 10:12:55.772644000 +0800
@@ -0,0 +1,338 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+
+
+
+
+
+#include <qtransform.h>
+#include <qvarlengtharray.h>
+#include <qcache.h>
+#include <qmath.h>
+#include <private/qpixmapdata_p.h>
+#include <private/qpixmap_raster_p.h>
+#include "ge2dpaintdevice.h"
+#include "ge2dlibscreen.h"
+#include "ge2dpaintengine.h"
+#include "ge2dlibsurface.h"
+#include "ge2d.h"
+#include "cmem.h"
+#include <stdio.h>
+#include <fcntl.h>
+#include <stdio.h>      // jpeglib needs this to be pre-included
+#include <sys/ioctl.h>
+
+#include <QApplication>
+#include <qdebug.h>
+#include <qwsdisplay_qws.h>
+
+static const qreal aliasedCoordinateDelta = 0.5 - 0.015625;
+static inline QRect toNormalizedFillRect(const QRectF &rect)
+{
+    const int x1 = qRound(rect.x() + aliasedCoordinateDelta);
+    const int y1 = qRound(rect.y() + aliasedCoordinateDelta);
+    const int x2 = qRound(rect.right() + aliasedCoordinateDelta);
+    const int y2 = qRound(rect.bottom() + aliasedCoordinateDelta);
+
+    return QRect(x1, y1, x2 - x1, y2 - y1).normalized();
+}
+
+static unsigned int  ImgFormat2Ge2dFormat(QImage::Format img_format)
+{
+	unsigned int format=0xffffffff;
+	
+	 switch (img_format) {
+	/* 32 bpp */
+    	case QImage::Format_RGB32:
+    	case QImage::Format_ARGB32:
+    	case QImage::Format_ARGB32_Premultiplied:
+		format = GE2D_FORMAT_S32_ARGB;
+		break;
+	/* 24 bpp */
+	case QImage::Format_RGB888:
+	case QImage::Format_RGB666:
+		format = GE2D_FORMAT_S24_RGB;
+		break;
+	case QImage::Format_ARGB6666_Premultiplied:
+	case QImage::Format_ARGB8555_Premultiplied:
+		format = GE2D_FORMAT_S24_ARGB_6666;
+		break;
+	case QImage::Format_ARGB8565_Premultiplied:
+		format = GE2D_FORMAT_S24_ARGB_8565;
+		break;
+	/* 16 bpp */
+    	case QImage::Format_RGB16:
+		format = GE2D_FORMAT_S16_RGB_565;
+	    break;
+    	case QImage::Format_RGB555:
+		format = GE2D_FORMAT_S16_ARGB_1555;
+		break;
+	case QImage::Format_ARGB4444_Premultiplied:
+    	case QImage::Format_RGB444:
+		format = GE2D_FORMAT_S16_ARGB_4444;
+		break;
+	default:
+    		qCritical("blit_32(): Image format %d not supported!", img_format);
+    	}
+	 return format;
+	
+}
+
+/*
+
+class QGE2DPaintEnginePrivate : public QRasterPaintEnginePrivate
+{
+public:
+   QGE2DPaintEnginePrivate(QGE2DPaintEngine *p);
+    ~QGE2DPaintEnginePrivate();
+	void begin(QPaintDevice *device);
+	void end() ;
+	void fillRect(const QRectF &r, const QColor &color);
+ private:   
+    QGE2DPaintEngine*q;
+    QGE2DBPaintDevice  *paint_dev;
+    Ge2dlibScreen  *screen;	
+    friend class QGE2DPaintEngine;
+} 
+
+*/
+
+QGE2DPaintEngine::QGE2DPaintEngine(QPaintDevice *device)
+:QRasterPaintEngine(device),paint_dev(device)
+{
+	
+}
+
+
+QGE2DPaintEngine::~QGE2DPaintEngine()
+{
+}
+void QRasterPaintEngine::updateOutlineMapper()
+{
+    Q_D(QRasterPaintEngine);
+    d->outlineMapper->setMatrix(state()->matrix);
+}
+inline void QGE2DPaintEngine::ensureOutlineMapper() {
+    if (d_func()->outlinemapper_xform_dirty)
+        updateOutlineMapper();
+}
+void QGE2DPaintEngine::updateState()
+{
+    QRasterPaintEngineState *s = state();
+
+    if (s->dirty & DirtyTransform)
+        updateMatrix(s->matrix);
+
+    if (s->dirty & (DirtyPen|DirtyCompositionMode)) {
+        const QPainter::CompositionMode mode = s->composition_mode;
+        s->flags.fast_text = (s->penData.type == QSpanData::Solid)
+                       && (mode == QPainter::CompositionMode_Source
+                           || (mode == QPainter::CompositionMode_SourceOver
+                               && qAlpha(s->penData.solid.color) == 255));
+    }
+
+    s->dirty = 0;
+}
+bool QGE2DPaintEngine::begin(QPaintDevice *device)
+{
+	
+   const bool status = QRasterPaintEngine::begin(device);
+   paint_dev=device; 
+   return status;
+}
+
+bool QGE2DPaintEngine::end()
+{
+     paint_dev=NULL; 
+    return QRasterPaintEngine::end();
+}
+
+void  QGE2DPaintEngine::fillRect_normalized(const QRect &r, QSpanData *data)
+{
+    Q_D(QGE2DPaintEngine);	
+    int x1, x2, y1, y2;
+
+    bool rectClipped = false;
+
+    if (data->clip) {
+        x1 = qMax(r.x(), data->clip->xmin);
+        x2 = qMin(r.x() + r.width(), data->clip->xmax);
+        y1 = qMax(r.y(), data->clip->ymin);
+        y2 = qMin(r.y() + r.height(), data->clip->ymax);
+        rectClipped = data->clip->hasRectClip;
+
+    } else if (d) {
+        x1 = qMax(r.x(), d->deviceRect.x());
+        x2 = qMin(r.x() + r.width(), d->deviceRect.x() + d->deviceRect.width());
+        y1 = qMax(r.y(), d->deviceRect.y());
+        y2 = qMin(r.y() + r.height(), d->deviceRect.y() + d->deviceRect.height());
+    } else {
+        x1 = qMax(r.x(), 0);
+        x2 = qMin(r.x() + r.width(), data->rasterBuffer->width());
+        y1 = qMax(r.y(), 0);
+        y2 = qMin(r.y() + r.height(), data->rasterBuffer->height());
+    }
+
+    if (x2 <= x1 || y2 <= y1)
+        return ;
+
+    const int width = x2 - x1;
+    const int height = y2 - y1;
+
+
+
+    bool isUnclipped = rectClipped
+                       || (d && d->isUnclipped_normalized(QRect(x1, y1, width, height)));
+
+    if (d && isUnclipped) {
+        const QPainter::CompositionMode mode = d->rasterBuffer->compositionMode;
+	 printf("enter unclip\n");
+	 fillRectConfig();
+	 fillRectOP(QRect(x1,y1,width,height),data->solid.color)	;
+	 return ;
+	 
+        if ( (mode == QPainter::CompositionMode_Source
+                               || (mode == QPainter::CompositionMode_SourceOver
+                                   && qAlpha(data->solid.color) == 255)))
+        {
+            	fillRectConfig();
+		fillRectOP(QRect(x1,y1,width,height),data->solid.color)	;	
+		return ;		
+        }
+    }
+	
+    ProcessSpans blend = isUnclipped ? data->unclipped_blend : data->blend;
+
+    const int nspans = 256;
+    QT_FT_Span spans[nspans];
+
+    Q_ASSERT(data->blend);
+    int y = y1;
+    while (y < y2) {
+        int n = qMin(nspans, y2 - y);
+        int i = 0;
+        while (i < n) {
+            spans[i].x = x1;
+            spans[i].len = width;
+            spans[i].y = y + i;
+            spans[i].coverage = 255;
+            ++i;
+        }
+
+        blend(n, spans, data);
+        y += n;
+    }
+
+}
+void QGE2DPaintEngine::fillRect(const QRectF &r, QSpanData *data)
+{
+    Q_D(QGE2DPaintEngine);
+    QRasterPaintEngineState *s = state();
+    	
+    if (!s->flags.antialiased) {
+        uint txop = s->matrix.type();
+        if (txop == QTransform::TxNone) {
+            fillRect_normalized(toNormalizedFillRect(r), data);
+            return;
+        } else if (txop == QTransform::TxTranslate) {
+            const QRect rr = toNormalizedFillRect(r.translated(s->matrix.dx(), s->matrix.dy()));
+            fillRect_normalized(rr, data);
+            return;
+        } else if (txop == QTransform::TxScale) {
+            const QRect rr = toNormalizedFillRect(s->matrix.mapRect(r));
+            fillRect_normalized(rr, data);
+            return;
+        }
+    }
+    ensureState();
+    if (s->flags.tx_noshear) {
+        d->initializeRasterizer(data);
+        QRectF nr = r.normalized();
+        if (!nr.isEmpty()) {
+            const QPointF a = s->matrix.map((nr.topLeft() + nr.bottomLeft()) * 0.5f);
+            const QPointF b = s->matrix.map((nr.topRight() + nr.bottomRight()) * 0.5f);
+            d->rasterizer->rasterizeLine(a, b, nr.height() / nr.width());
+        }
+        return;
+    }
+    printf("fill path\n");
+    QPainterPath path;
+    path.addRect(r);
+    ensureOutlineMapper();
+    fillPath(path, data);
+}
+void QGE2DPaintEngine::fillRect(const QRectF &rect, const QBrush &brush)
+{
+
+     //screen->solidFill(brush.color(),QRegion(rect.x(),rect.y(),rect.width(),rect.height(),QRegion::Rectangle))  ;
+     printf("brush\n");
+	QRasterPaintEngineState *s = state();
+
+    	ensureBrush(brush);
+    	if (!s->brushData.blend)
+      	  return;
+     	fillRect(rect,&s->brushData);
+}
+
+void QGE2DPaintEngine::fillRect(const QRectF &rect, const QColor &color)
+{
+	QRasterPaintEngine::fillRect(rect,color);
+	return ;
+	// Q_D(QGE2DPaintEngine);
+	// d->fillRect(rect,color);
+	//     printf("color\n");
+	
+}
+void  QGE2DPaintEngine::fillRectConfig()
+{
+	
+	QGE2DBPaintDevice   *pt_dev=(QGE2DBPaintDevice   *)paint_dev;
+	config_para_t ge2d_config;
+	QImage::Format format=pt_dev->format();
+       QWSDisplay::grab();
+	ge2d_config.src_dst_type = ALLOC_ALLOC;
+	ge2d_config.alu_const_color=0xff0000ff;
+	ge2d_config.src_format = ImgFormat2Ge2dFormat(format);
+	ge2d_config.dst_format = ImgFormat2Ge2dFormat(format);
+	ge2d_config.src_planes[0].w=pt_dev->size().width();
+	ge2d_config.src_planes[0].h=pt_dev->size().height();
+	ge2d_config.src_planes[0].addr=CMEM_getPhys(pt_dev->memory());
+	ge2d_config.dst_planes[0].w=pt_dev->size().width();
+	ge2d_config.dst_planes[0].h=pt_dev->size().height();
+	ge2d_config.dst_planes[0].addr=CMEM_getPhys(pt_dev->memory());
+
+	ioctl(Ge2dlibScreen::getDevFD(), FBIOPUT_GE2D_CONFIG, &ge2d_config);  
+	QWSDisplay::ungrab();
+	
+}
+void  QGE2DPaintEngine::fillRectOP(const  QRect  &rect,const QColor &color)
+{
+	
+	ge2d_op_para_t op_para;
+	QGE2DBPaintDevice   *pt_dev=(QGE2DBPaintDevice   *)paint_dev;
+	printf("offset:%d-%d\n",coordinateOffset().x(),coordinateOffset().y());
+	QWSDisplay::grab();
+	op_para.src1_rect.x = rect.x();
+      op_para.src1_rect.y = rect.y();
+      op_para.src1_rect.w = rect.width();
+      op_para.src1_rect.h = rect.height();
+	op_para.color = (color.blue()<<24)|(color.green()<<16)|(color.red()<<8)|color.alpha();
+         
+      ioctl(Ge2dlibScreen::getDevFD(), FBIOPUT_GE2D_FILLRECTANGLE, &op_para);
+	  QWSDisplay::grab();
+}
+/*
+void QGE2DPaintEngine::fillRects(const QRect *rects, int n)
+{
+	printf("fillrects\n");
+    for (int i = 0; i < n; ++i) {
+        const QRect r = transform.mapRect(rects[i]);
+        fillRectFill(QRect(r.x(),r.y(),r.width(),r.height()),state()->brush.color());
+		
+    }
+}*/
+
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.h qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.h
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.h	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2dpaintengine.h	2010-08-03 18:56:45.688893000 +0800
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 AMLOGIC, INC.
+** All rights reserved.
+****************************************************************************/
+
+#ifndef GE2D_PAINTENGINE_H
+#define GE2D_PAINTENGINE_H
+
+#include <QtGui/QtGui>
+#include <private/qpaintengine_raster_p.h>
+#include "Qt/private/qoutlinemapper_p.h"
+#include "ge2dlibscreen.h"
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+
+
+class QGE2DPaintEnginePrivate;
+class QGE2DPaintEngine : public QRasterPaintEngine
+{
+ Q_DECLARE_PRIVATE(QGE2DPaintEngine)
+  public:
+    QGE2DPaintEngine(QPaintDevice *device);
+	
+    ~QGE2DPaintEngine();
+
+   void fillRect(const QRectF &r, const QBrush &brush);
+   void fillRect(const QRectF &r, const QColor &color);
+   void fillRect(const QRectF &r, QSpanData *data);
+   //void fillRects(const QRect *rects, int n);*/
+   bool begin(QPaintDevice *device);
+   bool end();
+ private:
+	void updateState(void);
+	void updateOutlineMapper();
+	inline void ensureOutlineMapper();
+	inline void ensureBrush(const QBrush &brush) {
+        if (!qbrush_fast_equals(state()->lastBrush, brush) || state()->fillFlags)
+            updateBrush(brush);
+      } 	
+	void  fillRect_normalized(const QRect &r, QSpanData *data) ;
+	void  fillRectConfig();	
+   	void  fillRectOP(const  QRect  &rect,const QColor &color);
+ protected:
+    QPaintDevice  *paint_dev;
+     QTransform transform;	
+     
+	 inline void ensureState() {
+        if (state()->dirty)
+            updateState();
+    }
+
+
+};
+class
+#ifdef Q_WS_QWS
+Q_GUI_EXPORT
+#endif
+QGE2DPaintEnginePrivate : public QRasterPaintEnginePrivate
+{
+    Q_DECLARE_PUBLIC(QGE2DPaintEngine)
+public:
+	
+};
+	
+
+QT_END_NAMESPACE
+
+#endif // GE2D_PAINTENGINE_H
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2d.pro qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2d.pro
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/ge2d.pro	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/ge2d.pro	2010-08-04 11:27:01.544642000 +0800
@@ -0,0 +1,20 @@
+TEMPLATE = lib
+CONFIG += plugin
+
+LIBS += $(STAGING)/lib/libcmem.a
+INCPATH += $(STAGING)/include/
+INCPATH +=$$QT_SOURCE_TREE/src/3rdparty/libaml
+
+
+TARGET = ge2dlibscreen
+target.path = $$[QT_INSTALL_PLUGINS]/gfxdrivers
+INSTALLS += target
+
+HEADERS = ge2dlibscreen.h \
+          ge2dlibsurface.h \
+          ge2dlibsharedsurface.h
+SOURCES = ge2dlibscreen.cpp \
+          ge2dlibsurface.cpp \	
+          ge2dlibsharedsurface.cpp \
+          ge2dlibplugin.cpp           
+          
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/main_include.h qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/main_include.h
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/ge2d/main_include.h	1970-01-01 07:00:00.000000000 +0700
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/ge2d/main_include.h	2010-08-04 10:12:46.604643000 +0800
@@ -0,0 +1,6 @@
+#include "ge2dlibscreen.h"
+#include "ge2d.h"
+#include "ge2dpaintengine.h"
+#include "ge2dpaintdevice.h"
+#include "cmem.h"
+#include "ge2dlibsurface.h"
\ No newline at end of file
diff -uNr qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/gfxdrivers.pro qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/gfxdrivers.pro
--- qt-everywhere-opensource-src-4.6.2.ori/src/plugins/gfxdrivers/gfxdrivers.pro	2010-02-11 23:55:23.000000000 +0800
+++ qt-everywhere-opensource-src-4.6.2.chg/src/plugins/gfxdrivers/gfxdrivers.pro	2010-08-04 13:44:44.872643000 +0800
@@ -7,3 +7,4 @@
 contains(gfx-plugins, transformed)  :SUBDIRS += transformed
 contains(gfx-plugins, svgalib)      :SUBDIRS += svgalib
 contains(gfx-plugins, powervr)      :SUBDIRS += powervr
+SUBDIRS += ge2d
